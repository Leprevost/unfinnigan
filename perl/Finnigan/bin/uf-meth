#!/usr/bin/env perl

use strict;
use warnings;
use feature qw/state say/;
use 5.010;

use Getopt::Long;
use Pod::Usage;
use Finnigan;

my $option_help = 0;
my $option_man = 0;
my $option_dump = 0;
my $option_html = 0;
my $option_wiki = 0;
my $option_size = 0;
my $option_header = 0;
my $option_relative = 0;

Getopt::Long::Configure ("bundling");
GetOptions(
	   'help|?' => \$option_help,
	   'man' => \$option_man,
	   'dump|d' => \$option_dump,
	   'size|s' => \$option_size,
	   'html|h' => \$option_html,
	   'wiki|w' => \$option_wiki,
	   'relative|r' => \$option_relative,
	   'header|h' => \$option_header,
	  ) or pod2usage(2);
pod2usage(1) if $option_help;
pod2usage(-existstatus => 0, -verbose => 2) if $option_man;

@ARGV == 1 or do{ say STDERR "Expecting a single input file\n"; pod2usage(2) };

my $file = shift @ARGV;

-e $file or die "file '$file' does not exist";
-f $file or die "'$file' is not a plain file";
-s $file or die "'$file' has zero size";

# -----------------------------------------------------------------------------
open INPUT, "<$file" or die "can't open '$file': $!";
binmode INPUT;

my $header = Finnigan::FileHeader->decode(\*INPUT);
my $seq_row = Finnigan::SeqRow->decode(\*INPUT, $header->version);
my $cas_info = Finnigan::CASInfo->decode(\*INPUT);
my $rfi = Finnigan::RawFileInfo->decode(\*INPUT, $header->version);
my $mf = Finnigan::MethodFile->decode(\*INPUT);

if ( $option_size ) {
  if ( $option_header ) {
    say "size: " . $mf->header->size;
  }
  else {
    say "size: " . $mf->size;
  }
}

$option_dump = 1 if $option_header;

if ( $option_dump ) {
  if ( $option_html ) {
    if ( $option_header ) {
      $mf->header->dump(style => 'html', relative => $option_relative);
    }
    else {
      $mf->dump(style => 'html', relative => $option_relative);
    }
  }
  elsif ( $option_wiki ) {
    if ( $option_header ) {
      $mf->header->dump(style => 'wiki', relative => $option_relative);
    }
    else {
      $mf->dump(style => 'wiki', relative => $option_relative);
    }
  }
  else {
    if ( $option_header ) {
      $mf->header->dump(relative => $option_relative);
    }
    else {
      $mf->dump(relative => $option_relative);
    }
  }
}
else {
  if ( $option_html ) {
    foreach my $i ( 1 .. $mf->n ) {
      my ($tag1, $tag2) = $mf->instrument($i);
      say "$tag1 / $tag2";
    }
  }
  elsif ( $option_wiki ) {
    say "|| tag 1 || tag 2 ||";
    foreach my $i ( 1 .. $mf->n ) {
      my ($tag1, $tag2) = $mf->instrument($i);
      say "|| $tag1 || $tag2 ||";
    }
  }
  else {
    foreach my $i ( 1 .. $mf->n ) {
      my ($tag1, $tag2) = $mf->instrument($i);
      say "$tag1 / $tag2";
    }
  }
}

say "-------";
say "ole file size: " . $mf->ms_ole_data->size;
$mf->ms_ole_data->dump;

say "-------";
say "header size: " . $mf->ms_ole_data->header->size;
$mf->ms_ole_data->header->dump;

say "-------";
say "DIF size: " . $mf->ms_ole_data->dif->size;
$mf->ms_ole_data->dif->dump;

say "-------";
say "FAT size: " . $mf->ms_ole_data->fat(0)->size;
$mf->ms_ole_data->fat(0)->dump;

# use Data::Dumper;
# print Dumper($mf->ms_ole_data);


my $data;
print "------------------\n";
my $dir = new Finnigan::OLE2DirectoryEntry($mf->ms_ole_data, 1);
if ($data = $dir->data) {
  print $dir->name . ": $data\n";
}
else {
  print $dir->name . " has no data\n";
}

print "------------------\n";
$dir = new Finnigan::OLE2DirectoryEntry($mf->ms_ole_data, 3);
if ($data = $dir->data) {
  print $dir->name . ": $data\n";
}
else {
  print $dir->name . " has no data\n";
}

print "------------------\n";
$dir = new Finnigan::OLE2DirectoryEntry($mf->ms_ole_data, 14);
if ($data = $dir->data) {
  print $dir->name . ": $data\n";
}
else {
  print $dir->name . " has no data\n";
}

__END__
=head1 NAME

uf-meth - decode the RawFileInfo structure in a Finnigan raw file

=head1 SYNOPSIS

uf-meth [options] file

 Options:
   --help            brief help message
   --man             full documentation
   --html            requet html formatting of the dump
   --wiki            format as a wiki table
   --size            tell object size
   --header          dump the content of FileHeader instead of entire MethodFile
   --relative        show relative addresses

=head1 OPTIONS

=over 8

=item B<--help>

Print a brief help message and exit.

=item B<--man>

Print the manual page and exit.

=item B<--dump>

Prints the table listing all header fields with their seek addresses,
sizes, acess keys and values.

=item B<--html>

Dump as html table.

=item B<--wiki>

Dump as a wiki table.

=item B<--size>

Show structure size in bytes.

=item B<--header>

Dump the contents of RawFileInfoHeader, instead of the parent object.

=item B<--relative>

Show relative addresses of all itmes. The default is to show the
absolute seek address.

=back

=head1 DESCRIPTION

B<uf-meth>displays the contents of the RawFileInfo structure, or its
component RawFileInfoHeader.

It will return an error message if its input is not a Finnigan raw
file.

By default, it prints a summary of the object's data on a single line.

=head2 EXAMPLES

uf-meth sample.raw

  (displays a single line with file creation date, followed by the data and  RunHeader addresses)

uf-meth -d sample.raw

  (dumps a the entire RawFileInfo with absolute addresses)

uf-meth -dpr sample.raw

  (dumps the RawFileInfoHeader with relative addresses)


=cut

=cut
