#!/usr/bin/env perl

use strict;
use warnings;
use feature qw/state say/;
use 5.010;

use Getopt::Declare;
use Finnigan;

my $args = new Getopt::Declare q{
  [strict]
  [mutex: -h -w]
  [mutex: -e -l]
  [mutex: -e -d]
  [mutex: -e -p]
  [mutex: -l -p]
  [mutex: -H -c]
  -e[xtract]		extract the entire Microsoft Compound File (OLE2)
  -l[ist]		list the compound file's contents
  -p[ath]		gives the full path to a single component to be extracted
  -d[ump]		dump the raw method file or its components
  -h[tml]		dump as html [requires: -d || -l]
  -w[iki]		dump in wiki table format [requires: -d || -l]
  -r[elative]		show relative addersess in dump [requires: -d]
  -H[eader]		dump the Finnigan file header [requires: -d]
  -c[ontainer]		dump the OLE2 container [requires: -d]
  -s[ize]		tell object size in all forms of dump [requires: -d]
  <file>		input file [required]

Default:

  List instrument tag mapping (instrument name -> directory name)
}
  or exit(-1);

my $file = $args->{"<file>"};
-e $file or die "file '$file' does not exist";
-f $file or die "'$file' is not a plain file";
-s $file or die "'$file' has zero size";

# -----------------------------------------------------------------------------
open INPUT, "<$file" or die "can't open '$file': $!";
binmode INPUT;

my $header = Finnigan::FileHeader->decode(\*INPUT);
my $seq_row = Finnigan::SeqRow->decode(\*INPUT, $header->version);
my $cas_info = Finnigan::CASInfo->decode(\*INPUT);
my $rfi = Finnigan::RawFileInfo->decode(\*INPUT, $header->version);
my $mf = Finnigan::MethodFile->decode(\*INPUT);

if ( exists $args->{-s} ) {
  if ( exists $args->{-H} ) {
    say "size: " . $mf->header->size;
  }
  elsif ( exists $args->{-c} ) {
    say "size: " . $mf->container->size;
  }
  else {
    say "size: " . $mf->size;
  }
}

if ( exists $args->{-d} ) {
  if ( exists $args->{-h} ) {
    if ( exists $args->{-H} ) {
      $mf->header->dump(style => 'html', relative => exists $args->{-r});
    }
    elsif ( exists $args->{-c} ) {
      $mf->container->dump(style => 'html', relative => exists $args->{-r});
    }
    else {
      $mf->dump(style => 'html', relative => exists $args->{-r});
    }
  }
  elsif ( exists $args->{-w} ) {
    if ( exists $args->{-H} ) {
      $mf->header->dump(style => 'wiki', relative => exists $args->{-r});
    }
    elsif ( exists $args->{-c} ) {
      $mf->container->dump(style => 'wiki', relative => exists $args->{-r});
    }
    else {
      $mf->dump(style => 'wiki', relative => exists $args->{-r});
    }
  }
  else {
    if ( exists $args->{-H} ) {
      $mf->header->dump(relative => exists $args->{-r});
    }
    elsif ( exists $args->{-container} ) {
      $mf->header->dump(relative => exists $args->{-r});
    }
    else {
      $mf->dump(relative => exists $args->{-r});
    }
  }
}

elsif ( exists $args->{-l} ) {
  if ( exists $args->{-h} ) {
    $mf->container->list(style => 'html');
  }
  elsif ( exists $args->{-w} ) {
    $mf->container->(style => 'wiki');
  }
  else {
    $mf->container->list();
  }
}

elsif ( exists $args->{-e} ) {
  my $rec;
  my $bytes_to_read = $mf->file_size;
  my $addr = $mf->container->addr;
  seek INPUT, $addr, 0;
  my $nbytes = read INPUT, $rec, $bytes_to_read;
  $nbytes == $bytes_to_read
    or die "could not read $bytes_to_read bytes of the OLE2 container at $addr";
  print $rec;
}

else {
  # default (no options given)
  foreach my $i ( 1 .. $mf->n ) {
    my ($name, $dirname) = $mf->instrument_name($i);
    say "$name -> $dirname";
  }
}

# say "-------";
# say "ole file size: " . $mf->container->size;
# $mf->container->dump;

# say "-------";
# say "header size: " . $mf->container->header->size;
# $mf->container->header->dump;

# say "-------";
# say "DIF size: " . $mf->container->dif->size;
# $mf->container->dif->dump;

# say "-------";
# say "FAT size: " . $mf->container->fat(0)->size;
# $mf->container->fat(0)->dump;

# # use Data::Dumper;
# # print Dumper($mf->container);


# my $data;
# print "------------------\n";
# my $dir = new Finnigan::OLE2DirectoryEntry($mf->container, 1);
# if ($data = $dir->data) {
#   print $dir->name . ": $data\n";
# }
# else {
#   print $dir->name . " has no data\n";
# }

# print "------------------\n";
# $dir = new Finnigan::OLE2DirectoryEntry($mf->container, 3);
# if ($data = $dir->data) {
#   print $dir->name . ": $data\n";
# }
# else {
#   print $dir->name . " has no data\n";
# }

# print "------------------\n";
# $dir = new Finnigan::OLE2DirectoryEntry($mf->container, 14);
# if ($data = $dir->data) {
#   print $dir->name . ": $data\n";
# }
# else {
#   print $dir->name . " has no data\n";
# }

__END__
=head1 NAME

uf-meth - decode the embedded method file in a Finnigan raw file

=head1 SYNOPSIS

uf-meth [options] file

 Options:
   --help            brief help message
   --man             full documentation
   --html            requet html formatting of the dump
   --wiki            format as a wiki table
   --size            tell object size
   --H          dump the content of FileHeader instead of entire MethodFile
   --relative        show relative addresses

=head1 OPTIONS

=over 8

=item B<--help>

Print a brief help message and exit.

=item B<--man>

Print the manual page and exit.

=item B<--dump>

Prints the table listing all header fields with their seek addresses,
sizes, acess keys and values.

=item B<--html>

Dump as html table.

=item B<--wiki>

Dump as a wiki table.

=item B<-s[ize]>

Show structure size in bytes.

=item B<-H>

Dump the contents of RawFileInfoHeader, instead of the parent object.

=item B<--relative>

Show relative addresses of all itmes. The default is to show the
absolute seek address.

=back

=head1 DESCRIPTION

B<uf-meth>displays the contents of the RawFileInfo structure, or its
component RawFileInfoHeader.

It will return an error message if its input is not a Finnigan raw
file.

By default, it prints a summary of the object's data on a single line.

=head2 EXAMPLES

uf-meth sample.raw

  (displays a single line with file creation date, followed by the data and  RunHeader addresses)

uf-meth -d sample.raw

  (dumps a the entire RawFileInfo with absolute addresses)

uf-meth -dpr sample.raw

  (dumps the RawFileInfoHeader with relative addresses)


=cut

=cut
