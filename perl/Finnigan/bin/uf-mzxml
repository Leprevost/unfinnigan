#!/usr/bin/env perl

use strict;
use warnings FATAL => qw( all );
use feature qw/state say/;
use 5.010;

use Getopt::Declare;
use Finnigan;
use XML::Generator;
use Tie::IxHash;
use Storable qw(freeze thaw);
use MIME::Base64;
use Devel::Size qw(size total_size);


my $args = new Getopt::Declare q{
  [strict]
  -c[entroids]				write the list of centroided peaks instead of the scan profile
  -r[ange] <from:0+n> .. <to:0+n>	write only scans with numbers between <from> and <to>
  <file>				input file [required]
}
  or exit(-1);

my $file = $args->{"<file>"};
-e $file or die "file '$file' does not exist";
-f $file or die "'$file' is not a plain file";
-s $file or die "'$file' has zero size";

# -----------------------------------------------------------------------------
open INPUT, "<$file" or die "can't open '$file': $!";
binmode INPUT;

my $header = Finnigan::FileHeader->decode(\*INPUT);
my $seq_row = Finnigan::SeqRow->decode(\*INPUT, $header->version);
my $cas_info = Finnigan::CASInfo->decode(\*INPUT);
my $rfi = Finnigan::RawFileInfo->decode(\*INPUT, $header->version);

my $data_addr = $rfi->preamble->data_addr;
my $run_header_addr = $rfi->preamble->run_header_addr;

# fast-forward to RunHeader
seek INPUT, $run_header_addr, 0;
my $run_header = Finnigan::RunHeader->decode(\*INPUT, $header->version);
my $scan_index_addr = $run_header->sample_info->scan_index_addr;
my $trailer_addr = $run_header->trailer_addr;
my $params_addr = $run_header->params_addr;

# InstID follows immediately
my $inst = Finnigan::InstID->decode(\*INPUT);

# ---------------------------------------------------------------------
# fast-forward to ScanIndex
seek INPUT, $scan_index_addr, 0;

my %scan_index;
# this code is not fool-proof and is not finished! It assumes that
# there are exactly as many entries in ScanIndex as would fit
# between $first_scan and $last_scan. In other words, the internal
# indices and links are not checked.
my $first_scan = $run_header->sample_info->first_scan;
my $last_scan = $run_header->sample_info->last_scan;

# get the first entry
my $entry = Finnigan::ScanIndexEntry->decode(\*INPUT);
my $size = $entry->size;
seek INPUT, $scan_index_addr, 0; # step back for simplicity; we just
                                 # need to know the record size at
                                 # this point, to be able to skip records
my $from = exists $args->{-r} ? $args->{-r}{"<from>"} : $first_scan;
my $to = exists $args->{-r} ? $args->{-r}{"<to>"} : $last_scan;
die "inverted range: [$from .. $to]" if $from > $to;

if ( $from > $first_scan) {
  # skip these entries
  seek INPUT, $scan_index_addr + ($from - $first_scan)*$size, 0;
}
foreach my $i ($from - 1 .. $to - 1) {
  $scan_index{$i} = Finnigan::ScanIndexEntry->decode(\*INPUT)->values;
}

say STDERR "scan index size: " . total_size(\%scan_index)/1024/1024;

# ---------------------------------------------------------------------
# Now go read the trailer. Because the trailer records are of variable
# size, they are not directly addressable and all of them must be
# read, up to the highest number in the range.
seek INPUT, $trailer_addr, 0;

# read the number of ScanEvent records in the file
my $rec;
my $bytes_to_read = 4;
my $nbytes = read INPUT, $rec, $bytes_to_read;
$nbytes == $bytes_to_read
  or die "could not read all $bytes_to_read bytes of the trailer scan events count at $trailer_addr";
my $trailer_length = unpack 'V', $rec;

my %scan_event;
foreach my $i ( 0 .. $trailer_length - 1) {
  my $n = $i + 1;
  my $e = Finnigan::ScanEvent->decode(\*INPUT, $header->version)->purge_unused_data;
  next if $n < $from;
  $scan_event{$i} = $e;
  last if $n == $to;
}

# say STDERR "memory used: " . get_stat_info()->{vsize}/1024/1024 . " Mb";

# ---------------------------------------------------------------------
# Now read the ScanParameters stream. Its records have variable size
# and are not directly addressable, so all of them must be read, up to
# the highest number in the range.

# First, the in order to reach the ScanParameters header, the error
# log and the scan hierarchy must be read.

# error log
my $error_log_addr = $run_header->sample_info->error_log_addr;
seek INPUT, $error_log_addr, 0;

# read the number of ErrorLog records
$bytes_to_read = 4;
$nbytes = read INPUT, $rec, $bytes_to_read;
$nbytes == $bytes_to_read
  or die "could not read all $bytes_to_read bytes of the log record count at $error_log_addr";
my $error_log_length = unpack 'V', $rec;

foreach my $i ( 0 .. $error_log_length - 1) {
  my $e = Finnigan::Error->decode(\*INPUT);
  say STDERR "Error: (time = " . $e->time . "): " . $e->message;
}

# scan hierarchy -- not used at the moment; read to skip the correct number of bytes
# 1. read the number of scan segments
my $scan_hierachy_addr = tell INPUT;
$bytes_to_read = 4;
$nbytes = read INPUT, $rec, $bytes_to_read;
$nbytes == $bytes_to_read
  or die "could not read all $bytes_to_read bytes of the scan_segment count at $scan_hierachy_addr";
my $nsegs = unpack 'V', $rec;
foreach my $i ( 0 .. $nsegs - 1) {
  # 1. read the number of scan events in this segment
  my $scan_event_addr = tell INPUT;
  $bytes_to_read = 4;
  $nbytes = read INPUT, $rec, $bytes_to_read;
  $nbytes == $bytes_to_read
    or die "could not read all $bytes_to_read bytes of the log record count at $scan_event_addr";
  my $n = unpack 'V', $rec;
  foreach my $j ( 0 .. $n - 1) {
    my $e = Finnigan::ScanEventTemplate->decode(\*INPUT, $header->version);
  }
}

# now the file pointer is at the start of GenericDataHeader for ScanParameters
my $params_header = Finnigan::GenericDataHeader->decode(\*INPUT);

# with the header on hand, skip to the ScanParameters stream
seek INPUT, $params_addr, 0;

my %charge_state;
foreach my $i ( $first_scan - 1.. $last_scan - 1) {
  my $n = $i + 1;
  my $p = Finnigan::ScanParameters->decode(\*INPUT, $params_header->fields);
  next if $n < $from;
  $charge_state{$i} = $p->charge_state;
  last if $n == $to;
}

# say STDERR "memory used: " . get_stat_info()->{vsize}/1024/1024 . " Mb";

#------------------------------------------------------------------------------------------
# This is a reasonably good point to start generating the output. We
# know everything about the data, but haven't started reading the data
# itself

my $parent_scan_data; # for looking up the precursor ion for each of
                      # the dependent MS2

my %scan_data;
open SCANDATA, ">unfinnigan-scandata"
  or die "cannot open temp file 'unfinnigan-scandata': $!";
binmode SCANDATA;

my $xmlgen = XML::Generator->new(
				 pretty => 1,
#				 conformance => 'strict',
				 namespace => ['http://sashimi.sourceforge.net/schema_revision/mzXML_3.0'],
				);


tie my %msRunAttr, 'Tie::IxHash';
%msRunAttr = (
              scanCount => $last_scan - $first_scan + 1,
              startTime => sprintf("PT%.4fS", 60 * $run_header->sample_info->start_time),
              endTime   => sprintf("PT%.4fS", 60 * $run_header->sample_info->end_time),
             );

tie my %parentFileAttr, 'Tie::IxHash';
%parentFileAttr = (
              fileName => decode_string($seq_row->file_name),
              fileType => 'RAWData',
              fileSha1 => '0',
             );

tie my %msManufacturerAttr, 'Tie::IxHash';
%msManufacturerAttr = (
              category => 'msManufacturer',
              value => 'Thermo Scientific', # although it does not come from the file
             );

tie my %msModelAttr, 'Tie::IxHash';
%msModelAttr = (
              category => 'msModel',
              value => decode_string($inst->model),
             );

tie my %msIonisationAttr, 'Tie::IxHash';
%msIonisationAttr = (
              category => 'msIonisation',
              value => $scan_event{$from - 1}->preamble->ionization(decode => 1), # not knowing better;
                                                 # it can probably be found in the method file
             );

tie my %msAnalyzerAttr, 'Tie::IxHash';
%msAnalyzerAttr = (
              category => 'msMassAnalyzer',
              value => $scan_event{$from - 1}->preamble->analyzer(decode => 1), # not knowing better;
                                                 # it can probably be found in the method file
             );

tie my %msDetectorAttr, 'Tie::IxHash';
%msDetectorAttr = (
              category => 'msDetector',
              value => $scan_event{$from - 1}->preamble->detector(decode => 1), # not knowing better;
                                                 # it can probably be found in the method file
             );

tie my %acqSoftwareAttr, 'Tie::IxHash';
%acqSoftwareAttr = (
                 type => 'acquisition',
                 name => 'Xcalibur',     # what else?
                 version => decode_string($inst->software_version),
                );

tie my %dataProcessingAttr, 'Tie::IxHash';
%dataProcessingAttr = (
                       # centroided => 1,
                      );

tie my %convSoftwareAttr, 'Tie::IxHash';
%convSoftwareAttr = (
                     type => 'conversion',
                     name => 'unfinnigan',
                     version => $Finnigan::VERSION,
                    );

my $xml = $xmlgen->mzXML(
  ['http://sashimi.sourceforge.net/schema_revision/mzXML_3.0'],
  {
   'xmlns:xsi' => 'http://www.w3.org/2001/XMLSchema-instance',
   'xsi:schemaLocation' => 'http://sashimi.sourceforge.net/schema_revision/mzXML_3.0 http://sashimi.sourceforge.net/schema_revision/mzXML_3.0/mzXML_idx_3.0.xsd'
  },
  $xmlgen->msRun(\%msRunAttr,
    $xmlgen->parentFile(\%parentFileAttr),
    $xmlgen->msInstrument(
      $xmlgen->msManufacturer(\%msManufacturerAttr),
      $xmlgen->msModel(\%msModelAttr),
      $xmlgen->msIonisation(\%msIonisationAttr),
      $xmlgen->msMassAnalyzer(\%msAnalyzerAttr),
      $xmlgen->msDetector(\%msDetectorAttr),
      $xmlgen->software(\%acqSoftwareAttr),
    ),
    $xmlgen->dataProcessing(
      \%dataProcessingAttr,
      $xmlgen->software(\%convSoftwareAttr),
    ),
    map {
      my $n = $_;
      say STDERR "in outer map ($n)";
      my ( $attr ) = read_scan($n, $args, \%scan_index, \%scan_event, \%scan_data);
#      say STDERR "memory at scan $n: " . get_stat_info()->{vsize}/1024/1024 . " Mb";
      tie my %peakAttr, 'Tie::IxHash';
      %peakAttr = (
        precision       => 32,
        byteOrder       => "network",
        contentType     => "m/z-int",
        compressionType => "none",
        compressedLen   => 0,
      );
      $xmlgen->scan(
        $attr,
        $xmlgen->peaks(\%peakAttr, "=== cut ==="),
        map {
          my $n = $_;
          say STDERR "  in inner map ($n)";
          my ( $attr, $precursor_peak ) = read_scan($n, $args, \%scan_index, \%scan_event, \%scan_data);

          tie my %precursorAttr, 'Tie::IxHash';
          %precursorAttr = (
            precursorIntensity  => sprintf("%.2f",$precursor_peak->{intensity}),
            precursorCharge     => $charge_state{$n-1},
            activationMethod    => "unknown",
          );

          tie my %peaksAttr, 'Tie::IxHash';
          %peaksAttr = (
            precision       => 32,
            byteOrder       => "network",
            contentType     => "m/z-int",
            compressionType => "none",
            compressedLen   => 0,
          );
          $xmlgen->scan(
            $attr,
            $xmlgen->precursorMz(\%precursorAttr, $precursor_peak->{Mz}),
            $xmlgen->peaks(\%peaksAttr, "=== cut ===")
          )
        } dependent_scans(\%scan_event, $n)
      );
    } grep { $scan_event{$_ - 1}->preamble->ms_power == 1 } $from .. $to
  )
);

say STDERR "xml object size: " . total_size($xml);

my @xml_chunk = split "=== cut ===", "$xml";

close SCANDATA;
open SCANDATA, "<unfinnigan-scandata"
  or die "cannot open temp file 'unfinnigan-scandata': $!";


my %xml_scan_offset;
foreach my $n ( $from .. $to ) {
  my $i = $n - 1;
  my $chunk_no = $n - $from;

  my $rec;
  my ($pos, $bytes_to_read) = @{$scan_data{$i}};
  seek SCANDATA, $pos, 0;
  my $nbytes = read SCANDATA, $rec, $bytes_to_read;
  $nbytes == $bytes_to_read
    or die "could not read all $bytes_to_read bytes of the saved scan data at $pos";
  my $peaks = thaw $rec;

  my $buf;
  foreach my $peak ( @$peaks ) {
    $buf .= pack("NN", unpack("VV", pack("ff", @$peak)));
  }
  print $xml_chunk[$chunk_no];
  $xml_scan_offset{$i} = tell STDOUT;
  if ( $buf ) {
    print encode_base64($buf, "");
  }
  else {
    say STDERR "no data in scan $n";
  }
}
substr($xml_chunk[-1], -length("</mzXML>\n")) = "";
say $xml_chunk[-1];

my $index_offset = tell STDOUT;
say qq( <index name="scan" >);
foreach my $i (sort { $a <=> $b } keys %xml_scan_offset ) {
  my $n = $i + 1;
  say qq(   <offset id="$n">$xml_scan_offset{$i}</offset>);
}
say " </index>";
say " <indexOffset>$index_offset</indexOffset>";
say " <sha1></sha1>";
say "</mzXML>";

close SCANDATA;
unlink "unfinnigan-scandata";

sub min($$) { $_[$_[0] > $_[1]] }

sub decode_string {
  my $buf = shift;
  $buf =~ s/\x00//g;
  return $buf;
}

sub dependent_scans {
  my ($scan_event, $scan_no) = @_;
  my @list = ();
  return unless $scan_event->{$scan_no - 1};
  my $ms_power = $scan_event->{$scan_no - 1}->preamble->ms_power;
  return unless $ms_power == 1; # assume ms2 scans have no further dependents
  for ( my $i = $scan_no; 1; $i++ ) {
    last unless $scan_event{$i};
    my $ms_power = $scan_event->{$i}->preamble->ms_power;
    last unless $ms_power == 2;
    push @list, $i + 1;
  }
  return @list;
}

sub read_scan {
  my ($n, $args, $scan_index, $scan_event, $scan_data) = @_;
  my $i = $n-1;

  seek INPUT, $data_addr + $scan_index->{$i}->{offset}, 0;

  my $ph = Finnigan::PacketHeader->decode(\*INPUT);
  my $profile;
  $profile = Finnigan::Profile->decode(\*INPUT, $ph->layout) if $ph->profile_size;
  my $peaks;
  $peaks = Finnigan::Peaks->decode(\*INPUT) if $ph->peak_list_size;

  my $ms_power = $scan_event->{$i}->preamble->ms_power;

  # if there are no called peaks, treat the profile as a set of peaks
  my $peakCount;
  if ( exists $args->{-c} ) {
    $peakCount = $peaks->count;
  }
  else {
    # the M/z range; set it to full range, until the command-line argumnet is added
    my $range = [$scan_index->{$i}->{"low mz"}, $scan_index->{$i}->{"high mz"}];
    if ( $profile ) {
      $profile->set_converter($scan_event->{$i}->converter);
      $profile->set_inverse_converter($scan_event->{$i}->inverse_converter);
      my $bins;
      if ( $profile->peak_count > 1) {
        $bins = $profile->bins($range, "add empty bins"); # this call implicitly uses the forward converter
      }
      else {
        $bins = $profile->bins($range); # this call implicitly uses the forward converter
      }
      $peakCount = scalar @$bins;      
      say STDERR "freezing profile ($peakCount) $scan_event->{$i} at $i";
      my $pos = tell SCANDATA;
      print SCANDATA freeze $bins;
      $scan_data->{$i} = [$pos, tell(SCANDATA) - $pos];
    }
    elsif ( $peaks ) {
      say STDERR "freezing peak list $scan_event->{$i} at $i";
      my $pos = tell SCANDATA;
      print SCANDATA freeze $peaks->all;
      $scan_data->{$i} = [$pos, tell(SCANDATA) - $pos];
    }
    else {
      die "no data in scan $i?";
    }
    if ( $ms_power == 1 ) {
      $parent_scan_data = $profile ? $profile : $peaks;
    }
  }
  
  my %polarity_symbol = (
                         0 => "-",
                         1 => "+",
                         2 => "any",
                        );

  tie my %scanAttr, 'Tie::IxHash';
  %scanAttr = (
               num           => $n,
               msLevel       => $ms_power,
               peaksCount    => $peakCount,
               polarity      => $polarity_symbol{$scan_event->{$i}->preamble->polarity},
               scanType      => $scan_event->{$i}->preamble->scan_type(decode => 1),
               filterLine    => "$scan_event->{$i}",
               retentionTime => sprintf("PT%.4fS", 60 * $scan_index->{$i}->{"start time"}),
               lowMz         => $scan_index->{$i}->{"low mz"},
               highMz        => $scan_index->{$i}->{"high mz"},
               basePeakMz    => $scan_index->{$i}->{"base mz"},
               basePeakIntensity => $scan_index->{$i}->{"base intensity"},
               totIonCurrent => $scan_index->{$i}->{"total current"},
              );
  if ( $ms_power == 2 ) {
    $scanAttr{collisionEnergy} = $scan_event{$i}->reaction->energy;
    my $precursor_mz = $scan_event{$i}->reaction->precursor;
    my $precursor_peak = $parent_scan_data->find_precursor_peak($precursor_mz);
    $precursor_peak->{Mz} = $precursor_mz;
    return (\%scanAttr, $precursor_peak);
  }
  else {
    return (\%scanAttr);
  }
}


sub get_stat_info {  ## this will only work in Linux
  my $ref = {};

  ### open and read the main stat file
  if( ! open(_INFO,"</proc/$$/stat") ){
    die "Couldn't open /proc/$$/stat [$!]";
  }
  my @info = split(/\s+/,<_INFO>);
  close(_INFO);

  ### these are all the props (skip some)
  # pid(0) comm(1) state ppid pgrp session tty
  # tpgid(7) flags minflt cminflt majflt cmajflt
  # utime(13) stime cutime cstime counter
  # priority(18) timeout itrealvalue starttime vsize rss
  # rlim(24) startcode endcode startstack kstkesp kstkeip
  # signal(30) blocked sigignore sigcatch wchan
  ###

  ### get the important ones
  $ref = {utime  => $info[13] / 100,
          stime  => $info[14] / 100,
          cutime => $info[15] / 100,
          cstime => $info[16] / 100,
          vsize  => $info[22],
          rss    => $info[23] * 4};

  return $ref;
}

__END__
=head1 NAME

uf-mzxml - decode the ScanEvent structures in a Finnigan raw file "trailer"

=head1 SYNOPSIS

uf-mzxml [options] file

 Options:

  -a[ll]		        process all ScanEvent objects
  -c[oefficients]		print the table of conversion coefficients
  -n[unmber] <n:0+n>		extract ScanEvent number <n>
  -range <from:0+n> .. <to:0+n>	extract ScanEvent objects with numbers between <from> and <to>
  -d[ump]			dump all data in each ScanEvent
  -h[tml]			dump as html
  -w[iki]			dump in wiki table format
  -r[elative]			show relative addersess in dump
  <file>			input file

=head1 OPTIONS

=over 4

=item B<-help>

Print a brief help message and exits.

=item B<-d[ump]>

Prints a table listing all fields in ScanEvent entries, with their seek
addresses, sizes, names and values. Individual entries can be selected
with the B<-n[umber]> option or with the B<-range> option.

=item B<-n[umber]>

Gives the number of a single ScanEvent to process

=item B<-r[ange]>

Selects a range of the ScanEvent records to process

=item B<-h[tml]>

Format the dump output as an html table. When multiple entries are
specified, each will be rendered in its own table

=item B<-w[iki]>

Format the dump output as a wiki table.

=item B<-r[elative]>

Show relative addresses of all itmes in the dump. The default is to
show the absolute seek address. (works with the -d[ump] option)

=item B<-a[ll]>

Process all entries, including those that may lie outside the declared
range. It appears as though it can be possible to find more index
entries in the file than would fit between the first and the last scan
numbers specified in RunHeader/SampleInfo. In that case, in the
absence of the -all option, the entries will be enumerated according
to ScanIndex, which will be treated as a linked list -- starting with
the entry whose index matches the first scan number.

=back

=head1 DESCRIPTION

B<uf-mzxml> can be used to list or dump the ScanEvent records in a
Finnigan raw file. These records are stored in a stream Thermo calls a
"trailer", which follows the data stream. Now, the "trailer"
containing scan event descriptions is not the only stream trailing the
data; apparently, new ones were added as the format evolved, but the
name stuck. The code in Thermo libraries refers to this stream as
"TrailerScanEvent".

=head1 SEE ALSO

Finnigan::ScanEvent
Finnigan::ScanEventPreamble
Finnigan::FractionCollector
Finnigan::Reaction

=head1 EXAMPLES

uf-mzxml sample.raw 

  (will list all scan events in the file in Thermo's short-hand notation)

uf-mzxml -range 1..5 sample.raw

  (will list the first five records)

uf-mzxml -drn 5 ~/shared/test/sample4.raw 

  (will dump the fifth ScanEvent with relative addresses)

=cut

=cut
